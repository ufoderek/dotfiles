""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"" GVIM configuration for Windows
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"" From the default vimrc of GVIM
if has("gui_win32") || has("gui_win64")
    set nocompatible
    "source $VIMRUNTIME/vimrc_example.vim
    "source $VIMRUNTIME/mswin.vim
    "behave mswin

    set diffexpr=MyDiff()
    function MyDiff()
      let opt = '-a --binary '
      if &diffopt =~ 'icase' | let opt = opt . '-i ' | endif
      if &diffopt =~ 'iwhite' | let opt = opt . '-b ' | endif
      let arg1 = v:fname_in
      if arg1 =~ ' ' | let arg1 = '"' . arg1 . '"' | endif
      let arg2 = v:fname_new
      if arg2 =~ ' ' | let arg2 = '"' . arg2 . '"' | endif
      let arg3 = v:fname_out
      if arg3 =~ ' ' | let arg3 = '"' . arg3 . '"' | endif
      let eq = ''
      if $VIMRUNTIME =~ ' '
        if &sh =~ '\<cmd'
          let cmd = '""' . $VIMRUNTIME . '\diff"'
          let eq = '"'
        else
          let cmd = substitute($VIMRUNTIME, ' ', '" ', '') . '\diff"'
        endif
      else
        let cmd = $VIMRUNTIME . '\diff'
      endif
      silent execute '!' . cmd . ' ' . opt . arg1 . ' ' . arg2 . ' > ' . arg3 . eq
    endfunction
endif


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"" vim-plug configuration
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if has("gui_win32") || has("gui_win64")
  "for gVim without Cream
  call plug#begin('vimfiles/plugged')
else
  call plug#begin('~/.vim/plugged')
endif

Plug 'vim-airline/vim-airline'
Plug 'vim-airline/vim-airline-themes'
Plug 'bling/vim-bufferline'
Plug 'jnurmine/Zenburn'
Plug 'tpope/vim-commentary'
Plug 'christoomey/vim-tmux-navigator'
Plug 'tpope/vim-sleuth'
"Plug 'fholgado/minibufexpl.vim'
"Plug 'wikitopian/hardmode'

if !has("gui_win32") && !has("gui_win64")
  Plug 'terryma/vim-smooth-scroll'
  Plug 'airblade/vim-gitgutter'
  Plug 'vim-scripts/cscope.vim'
endif

call plug#end()


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"" Normal initialization
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

"" leader key
let mapleader = "\<space>"
let g:mapleader = "\<space>"

"" basic configs
set nocompatible
set showmode
set showcmd "show virtual mode selection area
set ttyfast "fast scroll in small files
set nobackup
set noswapfile
set autochdir "set dir to current file
"set wrap "wrap lines
set ruler "always show current position
set hid "change buffer without saving buffer
set nolazyredraw "don't redraw while executing macros
set showmatch "show matching brackets when text indicator is over them
set ffs=unix,dos,mac
set noerrorbells
set novisualbell
set t_vb=
set tm=500 "time out length
set colorcolumn=80
set cursorline "highlight current line
set backspace=indent,eol,start "let backspace delete over line breaks, tabs...
set whichwrap+=<,>,h,l,[,] "let h and l keys to wrap when used at beginning or end of lines
set mouse=a "support mouse in all modes so it won't copy line numbers
set wildmenu "use wildmenu for command auto-complete
set splitbelow "more natural
set splitright "more natural
syntax enable

"" encoding
if &encoding ==# 'latin1' && has('gui_running')
  set encoding=utf-8
endif

"" viminfo
if !empty(&viminfo)
  set viminfo^=!
endif

"" some useful remappings
map Y y$
inoremap jk <Esc>
cnoremap jk <C-c>
vnoremap q <Esc>
vnoremap v <Esc>

"" about split
nnoremap <silent> vv <C-w>v

"" reselect visual block after indent/outdent
vnoremap < <gv
vnoremap > >gv

"" return the cursor to the original location after .
nmap . .`[

"" goto next displayed line instead of physical line when long line is wrapped
nnoremap j gj
nnoremap k gk

"" switching buffers
set hidden "so any buffer can be hidden (keeping its changes) without first writing the buffer to a file
nmap <C-n> :bnext<CR>
nmap <C-p> :bprev<CR>
"nmap <C-K> :bhiden<CR>
"nmap <C-K> :bdelete<CR>

"" to make scrolling horizontally a bit more useful, try this: >
set sidescroll=5

"" set listchars
nnoremap <leader>L :set list listchars=tab:»·,trail:·,nbsp:+,eol:$,precedes:<,extends:><cr>

"" clear keywords highlight and list chars
nnoremap <leader><space> :noh<cr> :set nolist<cr>

"" remove all trailing whitespaces
nnoremap <leader>T :let _s=@/<Bar>:%s/\s\+$//e<Bar>:let @/=_s<Bar>:nohl<CR>

"" convert to UNIX format
nnoremap <leader>ffu :update<CR>:e ++fileformat=dos<CR>:setlocal fileformat=unix<CR>:w<CR>

"" convert to DOS format
nnoremap <leader>ffd :update<CR>:e ++fileformat=dos<CR>:w<CR>

"" paste without re-indent
set pastetoggle=<leader>p "toggle pastmode so you can paste without auto indent in putty

"" display as much as possible of the last line in a window will be displayed.
"" when not included, a last line that doesn't fit is replaced with "@" lines.
set display+=lastline

"" search in case-insensitive
nnoremap / /\v
vnoremap / /\v
nnoremap ? ?\v
vnoremap ? ?\v

"" search
set ignorecase
set smartcase
set gdefault
set incsearch
set showmatch
set hlsearch

"" search yanked text
vnorem // y/<c-r>"<cr>

"" using system clipboard for vim under terminal, need +xterm_clipboard
if has("mac")
    set clipboard=unnamed
elseif has("unix")
    set clipboard=unnamedplus
elseif has("win32")
    set clipboard=unnamed
endif

"" using system clipboard for GUI version of vim
if has("gui_win32") || has("gui_win64") || has("gui_mac")
    set clipboard=unnamed "Windows and Mac
elseif has("gui_running")
    set clipboard=unnamedplus "X Window
endif

"" set font for GUI version of vim
if has("gui_win32") || has("gui_win64")
    set guifont=Consolas:h16
elseif has("gui_gtk2")
    set guifont=Consolas\ 16
elseif has("gui_macvim")
    set guifont=Monaco:h18
endif

"" colorscheme
if has("gui_running") || &t_Co >= 256
    colorscheme zenburn
    let g:zenburn_hight_Contrast=1
elseif &t_Co >= 8
    colorscheme zenburn
    let g:zenburn_hight_Contrast=1
endif

"" cscope
set cscopequickfix=s-,c-,d-,i-,t-,e-
cnoreabbrev <expr> csa
  \ ((getcmdtype() == ':' && getcmdpos() <= 4)? 'cs add'  : 'csa')
cnoreabbrev <expr> csf
  \ ((getcmdtype() == ':' && getcmdpos() <= 4)? 'cs find' : 'csf')
cnoreabbrev <expr> csk
  \ ((getcmdtype() == ':' && getcmdpos() <= 4)? 'cs kill' : 'csk')
cnoreabbrev <expr> csr
  \ ((getcmdtype() == ':' && getcmdpos() <= 4)? 'cs reset' : 'csr')
cnoreabbrev <expr> css
  \ ((getcmdtype() == ':' && getcmdpos() <= 4)? 'cs show' : 'css')
cnoreabbrev <expr> csh
  \ ((getcmdtype() == ':' && getcmdpos() <= 4)? 'cs help' : 'csh')


"" for vim-airline
"let g:airline_theme='bubblegum'
"let g:airline_theme='angr'
"let g:airline_theme='base16'
"let g:airline_theme='base16_grayscale'
"let g:airline_symbols_ascii = 1
set laststatus=2 "always show status line
let g:airline#extensions#quickfix#quickfix_text = 'Quickfix'
let g:airline#extensions#quickfix#location_text = 'Location'
let g:airline#extensions#bufferline#enabled = 1
let g:airline#extensions#bufferline#overwrite_variables = 1


if !exists('g:airline_symbols')
let g:airline_symbols = {}
endif

" unicode symbols
let g:airline_left_sep = ''
let g:airline_symbols.crypt = ''
let g:airline_symbols.linenr = ''
let g:airline_symbols.maxlinenr = ''
let g:airline_symbols.branch = ''
let g:airline_symbols.paste = 'ρ'
let g:airline_symbols.spell = ''
let g:airline_symbols.notexists = ''
let g:airline_symbols.whitespace = ''


"" bufferline
let g:bufferline_echo=0
autocmd VimEnter * let &statusline='%{bufferline#refresh_status()}' .bufferline#get_status_string()

"" for MiniBufExpl
let g:miniBufExplorerHideWhenDiff=1
let g:miniBufExplStatusLineText=0
let g:miniBufExplUseSingleClick=1

"" indent
set autoindent "copy the indentation from the previous line
set nosmartindent
set nocindent
"set cinoptions=t0
"set shiftround "indent/outdent to nearest tabstops
filetype plugin on
filetype indent on

"" indent (leave default setting for vim-sleuth)
function Tab8()
    set noexpandtab "don't use space to replace tab
    set shiftwidth=8 "width of shift
    set tabstop=8 "width of tab
    set softtabstop=0 "width of tab, but insert spaces
endfunction

function Tab4()
    set noexpandtab "don't use space to replace tab
    set shiftwidth=4 "width of shift
    set tabstop=4 "width of tab
    set softtabstop=4 "width of tab, but insert spaces
endfunction

function Space4()
    set expandtab "use space to replace tab
    set shiftwidth=4 "width of shift
    set tabstop=4 "width of tab
    set softtabstop=4 "width of tab, but insert spaces
endfunction
nmap <leader>t8 :execute Tab8()<cr>
nmap <leader>t4 :execute Tab4()<cr>
nmap <leader>s4 :execute Space4()<cr>

"" gitgutter
highlight clear SignColumn

"" vim smooth scroll
if has("gui_win32") || has("gui_win64") || has("gui_mac")
  " do nothing
else
  noremap <silent> <c-u> :call smooth_scroll#up(&scroll, 0, 2)<CR>
  noremap <silent> <c-d> :call smooth_scroll#down(&scroll, 0, 2)<CR>
  noremap <silent> <c-b> :call smooth_scroll#up(&scroll*2, 0, 4)<CR>
  noremap <silent> <c-f> :call smooth_scroll#down(&scroll*2, 0, 4)<CR>
endif

"" avoid accidental mouse middle clicks
map <MiddleMouse> <Nop>
imap <MiddleMouse> <Nop>
map <2-MiddleMouse> <Nop>
imap <2-MiddleMouse> <Nop>
map <3-MiddleMouse> <Nop>
imap <3-MiddleMouse> <Nop>
map <4-MiddleMouse> <Nop>
imap <4-MiddleMouse> <Nop>

"" to resize vim split using mouse inside tmux
set mouse+=a
if &term =~ '^screen'
  " tmux knows the extended mouse mode
  set ttymouse=xterm2
endif

"" Increase/decrease font size
if has("gui_running")
nnoremap <C-kPlus> :silent! let &guifont = substitute(
\ &guifont,
\ ':h\zs\d\+',
\ '\=eval(submatch(0)+1)',
\ '')<cr>
nnoremap <C-kMinus> :silent! let &guifont = substitute(
\ &guifont,
\ ':h\zs\d\+',
\ '\=eval(submatch(0)-1)',
\ '')<cr>
endif

"" use real tab in makefiles
autocmd FileType make setlocal noexpandtab
